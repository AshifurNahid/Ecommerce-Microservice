<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/controller/CustomerController.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/controller/CustomerController.java" />
              <option name="originalContent" value="package com.nahid.customer.controller;&#10;&#10;import com.nahid.customer.dto.ApiResponse;&#10;import com.nahid.customer.dto.CustomerRequestDto;&#10;import com.nahid.customer.dto.CustomerResponseDto;&#10;import com.nahid.customer.enums.CustomerStatus;&#10;import com.nahid.customer.service.CustomerService;&#10;import com.nahid.customer.util.contant.ApiResponseConstant;&#10;import com.nahid.customer.util.contant.AppConstant;&#10;import com.nahid.customer.util.helper.ApiResponseUtil;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;&#10;@Slf4j&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/customers&quot;)&#10;@RequiredArgsConstructor&#10;public class CustomerController {&#10;&#10;    private final CustomerService customerService;&#10;&#10;&#10;    @PostMapping&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; createCustomer(@Valid @RequestBody CustomerRequestDto customerRequest) {&#10;        log.info(&quot;Received request to create customer with email: {}&quot;, customerRequest.getEmail());&#10;        CustomerResponseDto response = customerService.createCustomer(customerRequest);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.CREATE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; getCustomerById(@PathVariable String customerId) {&#10;        log.info(&quot;Received request to get customer with ID: {}&quot;, customerId);&#10;        CustomerResponseDto response = customerService.getCustomerById(customerId);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping(&quot;/email/{email}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; getCustomerByEmail(@PathVariable String email) {&#10;        log.info(&quot;Received request to get customer with email: {}&quot;, email);&#10;        CustomerResponseDto response = customerService.getCustomerByEmail(email);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @PutMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; updateCustomer(&#10;            @PathVariable String customerId,&#10;            @Valid @RequestBody CustomerRequestDto customerRequest) {&#10;        log.info(&quot;Received request to update customer with ID: {}&quot;, customerId);&#10;        CustomerResponseDto response = customerService.updateCustomer(customerId, customerRequest);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.UPDATE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; deleteCustomer(@PathVariable String customerId) {&#10;        log.info(&quot;Received request to delete customer with ID: {}&quot;, customerId);&#10;        customerService.deleteCustomer(customerId);&#10;        return ApiResponseUtil.success(null, String.format(ApiResponseConstant.DELETE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; getAllCustomers(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;lastName&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;asc&quot;) String sortDirection) {&#10;&#10;        log.info(&quot;Received request to get all customers - page: {}, size: {}&quot;, page, size);&#10;&#10;        Sort sort = sortDirection.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() :&#10;                Sort.by(sortBy).ascending();&#10;&#10;        Pageable pageable = PageRequest.of(page, size, sort);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.getAllCustomers(pageable);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_ALL_SUCCESSFUL, &quot;customers&quot;));&#10;    }&#10;&#10;    @GetMapping(&quot;/status/{status}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; getCustomersByStatus(&#10;            @PathVariable CustomerStatus status,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        log.info(&quot;Received request to get customers with status: {}&quot;, status);&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.getCustomersByStatus(status, pageable);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.STATUS_FILTERED_RESULTS, status));&#10;    }&#10;&#10;    @GetMapping(&quot;/search&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; searchCustomers(&#10;            @RequestParam String searchTerm,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        log.info(&quot;Received request to search customers with term: {}&quot;, searchTerm);&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.searchCustomers(searchTerm, pageable);&#10;        return ApiResponseUtil.success(response, ApiResponseConstant.SEARCH_RESULTS_FETCHED);&#10;    }&#10;&#10;    @PatchMapping(&quot;/{customerId}/status&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; updateCustomerStatus(&#10;            @PathVariable String customerId,&#10;            @RequestParam CustomerStatus status) {&#10;&#10;        log.info(&quot;Received request to update status for customer ID: {} to {}&quot;, customerId, status);&#10;        CustomerResponseDto response = customerService.updateCustomerStatus(customerId, status);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.STATUS_UPDATE_SUCCESSFUL, AppConstant.USER, status));&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.nahid.customer.controller;&#10;&#10;import com.nahid.customer.dto.ApiResponse;&#10;import com.nahid.customer.dto.CustomerRequestDto;&#10;import com.nahid.customer.dto.CustomerResponseDto;&#10;import com.nahid.customer.enums.CustomerStatus;&#10;import com.nahid.customer.service.CustomerService;&#10;import com.nahid.customer.util.contant.ApiResponseConstant;&#10;import com.nahid.customer.util.contant.AppConstant;&#10;import com.nahid.customer.util.helper.ApiResponseUtil;&#10;import jakarta.validation.Valid;&#10;import lombok.RequiredArgsConstructor;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.data.domain.Page;&#10;import org.springframework.data.domain.PageRequest;&#10;import org.springframework.data.domain.Pageable;&#10;import org.springframework.data.domain.Sort;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.web.bind.annotation.*;&#10;&#10;@Slf4j&#10;@RestController&#10;@RequestMapping(&quot;/api/v1/customers&quot;)&#10;@RequiredArgsConstructor&#10;public class CustomerController {&#10;&#10;    private final CustomerService customerService;&#10;&#10;&#10;    @PostMapping&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; createCustomer(@Valid @RequestBody CustomerRequestDto customerRequest) {&#10;        log.info(&quot;Received request to create customer with email: {}&quot;, customerRequest.getEmail());&#10;        CustomerResponseDto response = customerService.createCustomer(customerRequest);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.CREATE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; getCustomerById(@PathVariable String customerId) {&#10;        log.info(&quot;Received request to get customer with ID: {}&quot;, customerId);&#10;        CustomerResponseDto response = customerService.getCustomerById(customerId);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping(&quot;/email/{email}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; getCustomerByEmail(@PathVariable String email) {&#10;        log.info(&quot;Received request to get customer with email: {}&quot;, email);&#10;        CustomerResponseDto response = customerService.getCustomerByEmail(email);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @PutMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; updateCustomer(&#10;            @PathVariable String customerId,&#10;            @Valid @RequestBody CustomerRequestDto customerRequest) {&#10;        log.info(&quot;Received request to update customer with ID: {}&quot;, customerId);&#10;        CustomerResponseDto response = customerService.updateCustomer(customerId, customerRequest);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.UPDATE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @DeleteMapping(&quot;/{customerId}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Void&gt;&gt; deleteCustomer(@PathVariable String customerId) {&#10;        log.info(&quot;Received request to delete customer with ID: {}&quot;, customerId);&#10;        customerService.deleteCustomer(customerId);&#10;        return ApiResponseUtil.success(null, String.format(ApiResponseConstant.DELETE_SUCCESSFUL, AppConstant.USER));&#10;    }&#10;&#10;    @GetMapping&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; getAllCustomers(&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size,&#10;            @RequestParam(defaultValue = &quot;lastName&quot;) String sortBy,&#10;            @RequestParam(defaultValue = &quot;asc&quot;) String sortDirection) {&#10;&#10;        log.info(&quot;Received request to get all customers - page: {}, size: {}&quot;, page, size);&#10;&#10;        Sort sort = sortDirection.equalsIgnoreCase(&quot;desc&quot;) ?&#10;                Sort.by(sortBy).descending() :&#10;                Sort.by(sortBy).ascending();&#10;&#10;        Pageable pageable = PageRequest.of(page, size, sort);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.getAllCustomers(pageable);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.FETCH_ALL_SUCCESSFUL, AppConstant.CUSTOMERS));&#10;    }&#10;&#10;    @GetMapping(&quot;/status/{status}&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; getCustomersByStatus(&#10;            @PathVariable CustomerStatus status,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        log.info(&quot;Received request to get customers with status: {}&quot;, status);&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.getCustomersByStatus(status, pageable);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.STATUS_FILTERED_RESULTS, status));&#10;    }&#10;&#10;    @GetMapping(&quot;/search&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;Page&lt;CustomerResponseDto&gt;&gt;&gt; searchCustomers(&#10;            @RequestParam String searchTerm,&#10;            @RequestParam(defaultValue = &quot;0&quot;) int page,&#10;            @RequestParam(defaultValue = &quot;10&quot;) int size) {&#10;&#10;        log.info(&quot;Received request to search customers with term: {}&quot;, searchTerm);&#10;        Pageable pageable = PageRequest.of(page, size);&#10;        Page&lt;CustomerResponseDto&gt; response = customerService.searchCustomers(searchTerm, pageable);&#10;        return ApiResponseUtil.success(response, ApiResponseConstant.SEARCH_RESULTS_FETCHED);&#10;    }&#10;&#10;    @PatchMapping(&quot;/{customerId}/status&quot;)&#10;    public ResponseEntity&lt;ApiResponse&lt;CustomerResponseDto&gt;&gt; updateCustomerStatus(&#10;            @PathVariable String customerId,&#10;            @RequestParam CustomerStatus status) {&#10;&#10;        log.info(&quot;Received request to update status for customer ID: {} to {}&quot;, customerId, status);&#10;        CustomerResponseDto response = customerService.updateCustomerStatus(customerId, status);&#10;        return ApiResponseUtil.success(response, String.format(ApiResponseConstant.STATUS_UPDATE_SUCCESSFUL, AppConstant.USER, status));&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/exception/GlobalExceptionHandler.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/exception/GlobalExceptionHandler.java" />
              <option name="originalContent" value="package com.nahid.customer.exception;&#10;import com.nahid.customer.dto.ErrorResponse;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.FieldError;&#10;&#10;import org.springframework.web.bind.MethodArgumentNotValidException;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;&#10;import java.time.LocalDateTime;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice&#10;public class GlobalExceptionHandler {&#10;&#10;    @ExceptionHandler(CustomerNotFoundException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleCustomerNotFound(CustomerNotFoundException e) {&#10;        log.error(&quot;Customer not found: {}&quot;, e.getMessage());&#10;        ErrorResponse error = ErrorResponse.builder()&#10;                .timestamp(LocalDateTime.now())&#10;                .status(HttpStatus.NOT_FOUND.value())&#10;                .error(&quot;Customer Not Found&quot;)&#10;                .message(e.getMessage())&#10;                .build();&#10;        return new ResponseEntity&lt;&gt;(error, HttpStatus.NOT_FOUND);&#10;    }&#10;&#10;    @ExceptionHandler(CustomerAlreadyExistsException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleCustomerAlreadyExists(CustomerAlreadyExistsException e) {&#10;        log.error(&quot;Customer already exists: {}&quot;, e.getMessage());&#10;        ErrorResponse error = ErrorResponse.builder()&#10;                .timestamp(LocalDateTime.now())&#10;                .status(HttpStatus.CONFLICT.value())&#10;                .error(&quot;Customer Already Exists&quot;)&#10;                .message(e.getMessage())&#10;                .build();&#10;        return new ResponseEntity&lt;&gt;(error, HttpStatus.CONFLICT);&#10;    }&#10;&#10;    @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleValidationErrors(MethodArgumentNotValidException e) {&#10;        log.error(&quot;Validation error occurred&quot;);&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        e.getBindingResult().getAllErrors().forEach(error -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;&#10;        ErrorResponse error = ErrorResponse.builder()&#10;                .timestamp(LocalDateTime.now())&#10;                .status(HttpStatus.BAD_REQUEST.value())&#10;                .error(&quot;Validation Failed&quot;)&#10;                .message(&quot;Input validation failed&quot;)&#10;                .validationErrors(errors)&#10;                .build();&#10;        return new ResponseEntity&lt;&gt;(error, HttpStatus.BAD_REQUEST);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;ErrorResponse&gt; handleGenericException(Exception e) {&#10;        log.error(&quot;Unexpected error occurred: {}&quot;, e.getMessage(), e);&#10;        ErrorResponse error = ErrorResponse.builder()&#10;                .timestamp(LocalDateTime.now())&#10;                .status(HttpStatus.INTERNAL_SERVER_ERROR.value())&#10;                .error(&quot;Internal Server Error&quot;)&#10;                .message(&quot;An unexpected error occurred&quot;)&#10;                .build();&#10;        return new ResponseEntity&lt;&gt;(error, HttpStatus.INTERNAL_SERVER_ERROR);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.nahid.customer.exception;&#10;&#10;import com.nahid.customer.dto.ApiResponse;&#10;import com.nahid.customer.util.contant.ExceptionMessageConstant;&#10;import com.nahid.customer.util.helper.ApiResponseUtil;&#10;import lombok.extern.slf4j.Slf4j;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;import org.springframework.validation.FieldError;&#10;import org.springframework.web.bind.MethodArgumentNotValidException;&#10;import org.springframework.web.bind.annotation.ExceptionHandler;&#10;import org.springframework.web.bind.annotation.RestControllerAdvice;&#10;&#10;import java.util.HashMap;&#10;import java.util.Map;&#10;&#10;@Slf4j&#10;@RestControllerAdvice&#10;public class GlobalExceptionHandler {&#10;&#10;    @ExceptionHandler(CustomerNotFoundException.class)&#10;    public ResponseEntity&lt;ApiResponse&lt;Object&gt;&gt; handleCustomerNotFound(CustomerNotFoundException e) {&#10;        log.error(&quot;Customer not found: {}&quot;, e.getMessage());&#10;        return ApiResponseUtil.failureWithHttpStatus(e.getMessage(), HttpStatus.NOT_FOUND);&#10;    }&#10;&#10;    @ExceptionHandler(CustomerAlreadyExistsException.class)&#10;    public ResponseEntity&lt;ApiResponse&lt;Object&gt;&gt; handleCustomerAlreadyExists(CustomerAlreadyExistsException e) {&#10;        log.error(&quot;Customer already exists: {}&quot;, e.getMessage());&#10;        return ApiResponseUtil.failureWithHttpStatus(e.getMessage(), HttpStatus.CONFLICT);&#10;    }&#10;&#10;    @ExceptionHandler(MethodArgumentNotValidException.class)&#10;    public ResponseEntity&lt;ApiResponse&lt;Map&lt;String, String&gt;&gt;&gt; handleValidationErrors(MethodArgumentNotValidException e) {&#10;        log.error(&quot;Validation error occurred&quot;);&#10;        Map&lt;String, String&gt; errors = new HashMap&lt;&gt;();&#10;        e.getBindingResult().getAllErrors().forEach(error -&gt; {&#10;            String fieldName = ((FieldError) error).getField();&#10;            String errorMessage = error.getDefaultMessage();&#10;            errors.put(fieldName, errorMessage);&#10;        });&#10;&#10;        return ApiResponseUtil.failureWithHttpStatus(&quot;Input validation failed&quot;, HttpStatus.BAD_REQUEST, errors);&#10;    }&#10;&#10;    @ExceptionHandler(Exception.class)&#10;    public ResponseEntity&lt;ApiResponse&lt;Object&gt;&gt; handleGenericException(Exception e) {&#10;        log.error(&quot;Unexpected error occurred: {}&quot;, e.getMessage(), e);&#10;        return ApiResponseUtil.failure(&quot;An unexpected error occurred&quot;);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/ApiResponseConstant.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/ApiResponseConstant.java" />
              <option name="originalContent" value="package com.nahid.customer.util.contant;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ApiResponseConstant {&#10;&#10;    // General templates that work for any entity&#10;    public static final String FETCH_SUCCESSFUL = &quot;%s fetched successfully&quot;;&#10;    public static final String CREATE_SUCCESSFUL = &quot;%s created successfully&quot;;&#10;    public static final String UPDATE_SUCCESSFUL = &quot;%s updated successfully&quot;;&#10;    public static final String DELETE_SUCCESSFUL = &quot;%s deleted successfully&quot;;&#10;    public static final String FETCH_ALL_SUCCESSFUL = &quot;All %s retrieved successfully&quot;;&#10;    public static final String STATUS_UPDATE_SUCCESSFUL = &quot;%s status updated to %s successfully&quot;;&#10;&#10;    // Customer-specific constants (only for unique cases)&#10;    public static final String CUSTOMER_VERIFICATION_SUCCESS = &quot;Customer verified successfully&quot;;&#10;    public static final String CUSTOMER_PROFILE_COMPLETE = &quot;Customer profile is complete&quot;;&#10;    public static final String CUSTOMER_ADDRESS_OPERATION = &quot;Address %s successfully&quot;; // Accepts: added, updated, deleted&#10;}&#10;" />
              <option name="updatedContent" value="package com.nahid.customer.util.contant;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * Constants for API response messages used across the application.&#10; * Contains both general templates and entity-specific messages.&#10; */&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ApiResponseConstant {&#10;&#10;    // General templates that work for any entity&#10;    public static final String FETCH_SUCCESSFUL = &quot;%s fetched successfully&quot;;&#10;    public static final String CREATE_SUCCESSFUL = &quot;%s created successfully&quot;;&#10;    public static final String UPDATE_SUCCESSFUL = &quot;%s updated successfully&quot;;&#10;    public static final String DELETE_SUCCESSFUL = &quot;%s deleted successfully&quot;;&#10;    public static final String FETCH_ALL_SUCCESSFUL = &quot;All %s retrieved successfully&quot;;&#10;    public static final String STATUS_UPDATE_SUCCESSFUL = &quot;%s status updated to %s successfully&quot;;&#10;    &#10;    // Search and filter constants&#10;    public static final String SEARCH_RESULTS_FETCHED = &quot;Search results fetched successfully&quot;;&#10;    public static final String STATUS_FILTERED_RESULTS = &quot;Customers with status %s fetched successfully&quot;;&#10;&#10;    // Customer-specific constants (only for unique cases)&#10;    public static final String CUSTOMER_VERIFICATION_SUCCESS = &quot;Customer verified successfully&quot;;&#10;    public static final String CUSTOMER_PROFILE_COMPLETE = &quot;Customer profile is complete&quot;;&#10;    public static final String CUSTOMER_ADDRESS_OPERATION = &quot;Address %s successfully&quot;; // Accepts: added, updated, deleted&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/AppConstant.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/AppConstant.java" />
              <option name="originalContent" value="package com.nahid.customer.util.contant;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class AppConstant {&#10;&#10;    public static final String USER = &quot;user&quot;;&#10;    public static final String ROLE = &quot;role&quot;;&#10;&#10;}" />
              <option name="updatedContent" value="package com.nahid.customer.util.contant;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * Application-wide constants used for general purposes&#10; */&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class AppConstant {&#10;&#10;    public static final String USER = &quot;user&quot;;&#10;    public static final String USERS = &quot;users&quot;;&#10;    public static final String CUSTOMER = &quot;customer&quot;;&#10;    public static final String CUSTOMERS = &quot;customers&quot;;&#10;    public static final String ROLE = &quot;role&quot;;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/ExceptionMessageConstant.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/contant/ExceptionMessageConstant.java" />
              <option name="originalContent" value="package com.nahid.customer.util.contant;&#10;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ExceptionMessageConstant {&#10;&#10;    public static final String ENTITY_NOT_FOUND_BY_ID = &quot;%s not found with id: %s&quot;;&#10;    public static final String ERROR_MESSAGE_CONSTANT = &quot;%s error occurred due to %s&quot;;&#10;    public static final String UNIQUE_MESSAGE_TEMPLATE = &quot;%s must be unique&quot;;&#10;    public static final String ENTITY_ALREADY_EXISTS_TEMPLATE = &quot;%s already exists with %s: %s.&quot;;&#10;    public static final String ILLEGAL_OBJECT = &quot;Illegal object: %s&quot;;&#10;    public static final String INVALID_REQUEST = &quot;Invalid request: %s&quot;;&#10;    public static final String INVALID_REQUEST_TEMPLATE = &quot;Invalid request: %s. %s&quot;;&#10;&#10;    // Customer specific constants&#10;    public static final String CUSTOMER_NOT_FOUND_BY_ID = &quot;Customer not found with ID: %s&quot;;&#10;    public static final String CUSTOMER_NOT_FOUND_BY_EMAIL = &quot;Customer not found with email: %s&quot;;&#10;    public static final String CUSTOMER_ALREADY_EXISTS = &quot;Customer with email %s already exists&quot;;&#10;    public static final String CUSTOMER_EMAIL_EXISTS = &quot;Customer already exists with email: %s&quot;;&#10;    public static final String CUSTOMER_PHONE_EXISTS = &quot;Customer already exists with phone number: %s&quot;;&#10;    public static final String INVALID_CUSTOMER_DATA = &quot;Invalid customer data: %s&quot;;&#10;    public static final String CUSTOMER_STATUS_CHANGE_ERROR = &quot;Cannot change customer status from %s to %s&quot;;&#10;}&#10;" />
              <option name="updatedContent" value="package com.nahid.customer.util.contant;&#10;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;&#10;/**&#10; * Constants for exception messages used across the application.&#10; * Contains both general templates and entity-specific messages.&#10; */&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ExceptionMessageConstant {&#10;&#10;    // General templates that work for any entity&#10;    public static final String ENTITY_NOT_FOUND_BY_ID = &quot;%s not found with id: %s&quot;;&#10;    public static final String ENTITY_NOT_FOUND_BY_FIELD = &quot;%s not found with %s: %s&quot;;&#10;    public static final String ENTITY_ALREADY_EXISTS = &quot;%s already exists with %s: %s&quot;;&#10;    public static final String UNIQUE_FIELD_VIOLATION = &quot;%s must be unique&quot;;&#10;    public static final String ERROR_OCCURRED = &quot;%s error occurred due to %s&quot;;&#10;    public static final String ILLEGAL_OBJECT = &quot;Illegal object: %s&quot;;&#10;    public static final String INVALID_REQUEST = &quot;Invalid request: %s&quot;;&#10;    public static final String INVALID_REQUEST_TEMPLATE = &quot;Invalid request: %s. %s&quot;;&#10;    public static final String STATUS_CHANGE_ERROR = &quot;Cannot change %s status from %s to %s&quot;;&#10;&#10;    // Customer-specific constants (only for cases that don't fit general templates)&#10;    public static final String CUSTOMER_VERIFICATION_FAILED = &quot;Customer verification failed: %s&quot;;&#10;    public static final String CUSTOMER_ACCOUNT_LOCKED = &quot;Customer account is locked. Please contact support.&quot;;&#10;    public static final String CUSTOMER_ACCOUNT_DISABLED = &quot;Customer account is disabled.&quot;;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/helper/ApiResponseUtil.java">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/service/customer/src/main/java/com/nahid/customer/util/helper/ApiResponseUtil.java" />
              <option name="originalContent" value="package com.nahid.customer.util.helper;&#10;&#10;import java.time.Instant;&#10;&#10;import com.nahid.customer.dto.ApiResponse;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ApiResponseUtil {&#10;&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; success(T data, String message){&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(true)&#10;                .message(message)&#10;                .data(data)&#10;                .timestamp(Instant.now())&#10;                .statusCode(HttpStatus.OK.value())&#10;                .build();&#10;        return ResponseEntity.status(HttpStatus.OK).body(response);&#10;    }&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; failure(String message) {&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(false)&#10;                .message(message)&#10;                .data(null)&#10;                .timestamp(Instant.now())&#10;                .statusCode(HttpStatus.INTERNAL_SERVER_ERROR.value())&#10;                .build();&#10;&#10;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;    }&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; failureWithHttpStatus(String message, HttpStatus httpStatus) {&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(false)&#10;                .message(message)&#10;                .data(null)&#10;                .timestamp(Instant.now())&#10;                .statusCode(httpStatus.value())&#10;                .build();&#10;&#10;        return ResponseEntity.status(httpStatus).body(response);&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.nahid.customer.util.helper;&#10;&#10;import java.time.Instant;&#10;&#10;import com.nahid.customer.dto.ApiResponse;&#10;import lombok.AccessLevel;&#10;import lombok.NoArgsConstructor;&#10;import org.springframework.http.HttpStatus;&#10;import org.springframework.http.ResponseEntity;&#10;&#10;@NoArgsConstructor(access = AccessLevel.PRIVATE)&#10;public class ApiResponseUtil {&#10;&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; success(T data, String message){&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(true)&#10;                .message(message)&#10;                .data(data)&#10;                .timestamp(Instant.now())&#10;                .statusCode(HttpStatus.OK.value())&#10;                .build();&#10;        return ResponseEntity.status(HttpStatus.OK).body(response);&#10;    }&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; failure(String message) {&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(false)&#10;                .message(message)&#10;                .data(null)&#10;                .timestamp(Instant.now())&#10;                .statusCode(HttpStatus.INTERNAL_SERVER_ERROR.value())&#10;                .build();&#10;&#10;        return ResponseEntity.status(HttpStatus.INTERNAL_SERVER_ERROR).body(response);&#10;    }&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; failureWithHttpStatus(String message, HttpStatus httpStatus) {&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(false)&#10;                .message(message)&#10;                .data(null)&#10;                .timestamp(Instant.now())&#10;                .statusCode(httpStatus.value())&#10;                .build();&#10;&#10;        return ResponseEntity.status(httpStatus).body(response);&#10;    }&#10;&#10;    public static &lt;T&gt; ResponseEntity&lt;ApiResponse&lt;T&gt;&gt; failureWithHttpStatus(String message, HttpStatus httpStatus, T data) {&#10;        ApiResponse&lt;T&gt; response = ApiResponse.&lt;T&gt;builder()&#10;                .success(false)&#10;                .message(message)&#10;                .data(data)&#10;                .timestamp(Instant.now())&#10;                .statusCode(httpStatus.value())&#10;                .build();&#10;&#10;        return ResponseEntity.status(httpStatus).body(response);&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>